<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Fitting Room</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter", "Helvetica Neue", Arial, sans-serif;
      background: radial-gradient(120% 120% at 50% 0%, #1e2433 0%, #0c0e16 55%, #07080f 100%);
      color: #e6e9f2;
      overflow: hidden;
    }
    #app {
      position: fixed;
      inset: 0;
    }
    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #hud {
      position: absolute;
      left: 50%;
      bottom: 32px;
      transform: translateX(-50%);
      display: flex;
      gap: 16px;
      padding: 12px 16px;
      background: rgba(9, 11, 18, 0.72);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 14px;
      box-shadow: 0 15px 45px rgba(0, 0, 0, 0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }
    #hud.visible {
      opacity: 1;
      pointer-events: auto;
    }
    #welcome-overlay {
      position: absolute;
      left: 0;
      top: 0;
      width: 50%;
      height: 100%;
      background: rgba(9, 11, 18, 0.95);
      backdrop-filter: blur(20px);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 40px;
      box-sizing: border-box;
      transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 100;
    }
    #welcome-overlay.slide-out {
      transform: translateX(-100%);
    }
    /* Mobile styles - full screen layout */
    @media (max-width: 768px) {
      #welcome-overlay {
        width: 100%;
      }
      #welcome-overlay.slide-out {
        display: none;
      }
      /* Mobile: position arrows at screen edges */
      .arrow-controls {
        width: 100%;
      }
      .arrow-btn.left {
        left: 10px !important;
        right: auto !important;
      }
      .arrow-btn.right {
        right: 10px !important;
        left: auto !important;
      }
      /* Keep individual clothing type vertical positions */
      .arrow-controls.shirts {
        top: 25%;
      }
      .arrow-controls.pants {
        top: 45%;
      }
      .arrow-controls.shoes {
        top: 65%;
      }
      .arrow-controls.dresses {
        top: 35%;
      }
    }
    #welcome-content {
      text-align: center;
      max-width: 400px;
    }
    #welcome-content h1 {
      font-size: 48px;
      font-weight: 700;
      margin: 0 0 20px 0;
      background: linear-gradient(135deg, #9fb3ff 0%, #6a85ff 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    #welcome-content p {
      font-size: 18px;
      color: rgba(230, 233, 242, 0.8);
      margin: 0 0 40px 0;
      line-height: 1.6;
    }
    #go-button {
      background: linear-gradient(135deg, #3f5efb 0%, #6a85ff 100%);
      border: none;
      color: #fff;
      padding: 16px 48px;
      border-radius: 12px;
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 10px 30px rgba(82, 114, 255, 0.4);
    }
    #go-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 15px 40px rgba(82, 114, 255, 0.5);
    }
    #go-button:active {
      transform: translateY(0);
    }
    .arrow-controls {
      position: absolute;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }
    .arrow-controls.visible {
      opacity: 1;
      pointer-events: auto;
    }
    /* On desktop, hide arrows initially until button is clicked, except dresses */
    @media (min-width: 769px) {
      .arrow-controls:not(.show-after-click):not(.dresses) {
        opacity: 0 !important;
        pointer-events: none !important;
      }
      .arrow-controls.show-after-click.visible {
        opacity: 1 !important;
        pointer-events: auto !important;
      }
      /* Dresses arrows always visible on desktop */
      .arrow-controls.dresses.visible {
        opacity: 1 !important;
        pointer-events: auto !important;
      }
    }
    .arrow-btn {
      position: absolute;
      width: 56px;
      height: 56px;
      background: none;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      padding: 0;
    }
    .arrow-btn:hover {
      transform: scale(1.2);
    }
    .arrow-btn:active {
      transform: scale(1.1);
      transition: all 0.1s ease;
    }
    /* Modern chevron arrows using CSS - grey sleek color */
    .arrow-btn.left::before,
    .arrow-btn.right::before {
      content: '';
      display: block;
      width: 18px;
      height: 18px;
      border-top: 3px solid rgba(180, 180, 180, 0.85);
      border-right: 3px solid rgba(180, 180, 180, 0.85);
      margin: auto;
      transition: all 0.3s ease;
    }
    .arrow-btn.left::before {
      transform: rotate(-135deg);
    }
    .arrow-btn.right::before {
      transform: rotate(45deg);
    }
    .arrow-btn:hover::before {
      border-color: rgba(220, 220, 220, 1);
      border-width: 3.5px;
    }
    .arrow-btn.left:hover::before {
      transform: rotate(-135deg) translateX(-3px);
    }
    .arrow-btn.right:hover::before {
      transform: rotate(45deg) translateX(3px);
    }
    /* Desktop: position arrows with consistent spacing from center (responsive to viewport) */
    .arrow-btn.left {
      left: calc(50% - 180px);
    }
    .arrow-btn.right {
      right: calc(50% - 180px);
    }
    /* Tablet: slightly closer spacing */
    @media (max-width: 1024px) {
      .arrow-btn.left {
        left: calc(50% - 140px);
      }
      .arrow-btn.right {
        right: calc(50% - 140px);
      }
    }
    /* Small screens: closer to center */
    @media (max-width: 900px) {
      .arrow-btn.left {
        left: calc(50% - 100px);
      }
      .arrow-btn.right {
        right: calc(50% - 100px);
      }
    }
    /* Mobile: position arrows at screen edges */
    @media (max-width: 768px) {
      .arrow-btn.left {
        left: 10px !important;
        right: auto !important;
      }
      .arrow-btn.right {
        right: 10px !important;
        left: auto !important;
      }
    }
    .arrow-btn.single {
      left: 50%;
      transform: translateX(-50%);
    }
    /* Position arrow controls for each clothing type - closer to center where clothes are */
    .arrow-controls.shirts {
      top: 25%;
      left: 0;
      right: 0;
    }
    .arrow-controls.pants {
      top: 45%;
      left: 0;
      right: 0;
    }
    .arrow-controls.shoes {
      top: 65%;
      left: 0;
      right: 0;
    }
    .arrow-controls.dresses {
      top: 35%;
      left: 0;
      right: 0;
    }
    #mode-button {
      position: absolute;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      background: linear-gradient(135deg, #3f5efb 0%, #6a85ff 100%);
      border: none;
      color: #fff;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.5px;
      cursor: pointer;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease, transform 0.2s ease;
      box-shadow: 0 10px 30px rgba(82, 114, 255, 0.4);
    }
    #mode-button.visible {
      opacity: 1;
      pointer-events: auto;
    }
    #mode-button:hover {
      transform: translateX(-50%) translateY(-2px);
      box-shadow: 0 15px 40px rgba(82, 114, 255, 0.5);
    }
    #mode-button:active {
      transform: translateX(-50%) translateY(0);
    }
    /* Toast removed */
  </style>
</head>
<body>
  <div id="app">
    <canvas id="canvas"></canvas>
    <div id="welcome-overlay">
      <div id="welcome-content">
        <h1>Welcome</h1>
        <p>Experience our 3D fitting room. Explore different styles and see how they look together.</p>
        <button id="go-button">Go</button>
      </div>
    </div>
    <div class="arrow-controls shirts visible" data-type="shirts" id="shirts-controls">
      <button class="arrow-btn left" data-type="shirts" data-dir="-1"></button>
      <button class="arrow-btn right" data-type="shirts" data-dir="1"></button>
      </div>
    <div class="arrow-controls pants visible" data-type="pants">
      <button class="arrow-btn left" data-type="pants" data-dir="-1"></button>
      <button class="arrow-btn right" data-type="pants" data-dir="1"></button>
      </div>
    <div class="arrow-controls shoes visible" data-type="shoes">
      <button class="arrow-btn left" data-type="shoes" data-dir="-1"></button>
      <button class="arrow-btn right" data-type="shoes" data-dir="1"></button>
      </div>
    <div class="arrow-controls dresses" data-type="dresses" style="display: none;">
      <button class="arrow-btn left" data-type="dresses" data-dir="-1"></button>
      <button class="arrow-btn right" data-type="dresses" data-dir="1"></button>
    </div>
    <button id="mode-button">Dresses</button>
  </div>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
    </script>
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
    import { RoomEnvironment } from "https://unpkg.com/three@0.160.0/examples/jsm/environments/RoomEnvironment.js";

    // Assets manifest - inline dictionary (no separate file needed)
    const manifest = {
      shirts: [
        "object_0-10.glb",
        "object_0-11.glb",
        "object_0-12.glb",
        "object_0-13.glb",
        "object_0.glb"
      ],
      pants: [
        "WDressPants1.glb",
        "pant1.glb",
        "pant2.glb",
        "pant3.glb",
        "pant4.glb",
        "WDressPants2.glb",
        "WLeggings1.glb",
        "WLeggings2.glb",
        "MDressPants1.glb",
        "MDressPants2.glb",
        "wjeans1.glb",
        "wjeans2.glb",
        "wjeans3.glb",
        "mjeans1.glb",
        "mjeans2.glb",
        "mjeans3.glb"
      ],
      shoes: [
        "object_0-13.glb",
        "object_0-15.glb",
        "WTennisShoes1.glb",
        "MBasketBallShoes1.glb",
        "MTennisShoes1.glb"
      ],
      dresses: [
        "wdress1.glb",
        "wdress2.glb",
        "wdress3.glb"
      ],
      shorts: [
        "MShorts1.glb",
        "MShorts2.glb",
        "WShorts1.glb",
        "WShorts2.glb",
        "WSkirt1.glb",
        "WSkirt2.glb"
      ]
    };
    
    // Helper to check if an item is a short
    function isShort(filepath) {
      return filepath.includes('/shorts/');
    }
    
    // Build asset paths from manifest dictionary
    const pantsItems = manifest.pants ? manifest.pants.map(file => `../pants/${file}`) : [];
    const shortsItems = manifest.shorts ? manifest.shorts.map(file => `../shorts/${file}`) : [];
    
    // Build full paths from manifest
    const assets = {
      shirts: manifest.shirts ? manifest.shirts.map(file => `../shirts/${file}`) : [],
      pants: [...pantsItems, ...shortsItems], // Combine pants and shorts
      shoes: manifest.shoes ? manifest.shoes.map(file => `../shoes/${file}`) : [],
      dresses: manifest.dresses ? manifest.dresses.map(file => `../dresses/${file}`) : []
    };
    
    console.log("Loaded assets from manifest:", assets);

    const verticalOffsets = {
      shoes: 1.2,      // raised up more
      pants: 2.4,      // noticeably above shoes (includes shorts)
      shirts: 4.5,     // noticeably above pants
      dresses: 2.8,    // lower position (was 3.45)
    };

    const zOffsets = {
      shoes: 0.12,      // raised up more
      pants: 0,        // noticeably above shoes (includes shorts)
      shirts: 0,       // noticeably above pants
      dresses: 0,      // same z as other items
    };

    // Mobile detection (needed for positioning)
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;

    // Position constants
    // On mobile, start from left; on desktop, start from right
    const rightCenterX = 2.5; // initial position (on the right side of screen - desktop)
    const leftCenterX = -2.5; // initial position (on the left side of screen - mobile)
    const targetCenterX = 0; // final center position
    const rightCenterY = -0.5; // initial Y position (lower when on the right)
    const leftCenterY = -0.5; // initial Y position (lower when on the left)
    const targetCenterY = 0; // final Y position (normal center height)
    
    // Set initial position based on device type
    const initialX = isMobile ? leftCenterX : rightCenterX;
    const initialY = isMobile ? leftCenterY : rightCenterY;

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x090b12, 12, 30);

    const canvas = document.getElementById("canvas");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 7.5, 14);
    scene.add(camera);

    const pmrem = new THREE.PMREMGenerator(renderer);
    scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), 0.02).texture;

    const controls = new OrbitControls(camera, renderer.domElement);
    // Keep camera looking at center initially, items will be on the right
    controls.target.set(0, 3.4, 0);
    controls.enableDamping = true;
    controls.minDistance = 4;
    controls.maxDistance = 14;
    controls.maxPolarAngle = Math.PI * 0.55;

    const hemiLight = new THREE.HemisphereLight(0x8fb2ff, 0x0b0d14, 0.75);
    hemiLight.position.set(0, 6, 0);
    scene.add(hemiLight);

    const keyLight = new THREE.DirectionalLight(0xffffff, 1.35);
    keyLight.position.set(6, 8, 8);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.set(2048, 2048);
    keyLight.shadow.bias = -0.0005;
    scene.add(keyLight);

    const rimLight = new THREE.DirectionalLight(0x96b3ff, 0.5);
    rimLight.position.set(-5, 4, -4);
    scene.add(rimLight);

    const loader = new GLTFLoader();
    const current = { shirts: 0, pants: 0, shoes: 0, dresses: 0 };
    
    // Mode state: 'casual' (shirts+pants) or 'dresses'
    let currentMode = 'casual';
    
    // Carousel structure: each type has 3 slots (prev, current, next)
    const carouselSlots = {
      shirts: { prev: new THREE.Group(), current: new THREE.Group(), next: new THREE.Group() },
      pants: { prev: new THREE.Group(), current: new THREE.Group(), next: new THREE.Group() },
      shoes: { prev: new THREE.Group(), current: new THREE.Group(), next: new THREE.Group() },
      dresses: { prev: new THREE.Group(), current: new THREE.Group(), next: new THREE.Group() }
    };
    
    // Carousel configuration - must be declared before use
    // The pivot point is behind the current item, and items rotate around this pivot
    const CAROUSEL_PIVOT_BACK = 4.5; // How far behind the center item the pivot should be (larger = pivot further back)
    const CAROUSEL_RADIUS = CAROUSEL_PIVOT_BACK; // Distance from pivot to items (should match pivot distance for proper centering)
    const CAROUSEL_ANGLE = Math.PI / 4.5; // ~40 degrees between items (~20 degrees each side)
    const CAROUSEL_SCALE_SIDE = 0.75; // Scale for prev/next items
    
    // Carousel groups - each type has its own carousel group that rotates
    const carouselGroups = {
      shirts: new THREE.Group(),
      pants: new THREE.Group(),
      shoes: new THREE.Group(),
      dresses: new THREE.Group()
    };
    
      // Add all slots to their respective carousel groups
      Object.keys(carouselSlots).forEach(type => {
        carouselGroups[type].add(
          carouselSlots[type].prev,
          carouselSlots[type].current,
          carouselSlots[type].next
        );
        // Position the pivot point behind the center item
        // The pivot is at the carouselGroup origin
        // We want: center item at world z ≈ 0, pivot at world z = -CAROUSEL_PIVOT_BACK (behind center)
        // Center item is positioned at (0, 0, CAROUSEL_RADIUS) relative to pivot
        // So: group.position.z = -CAROUSEL_PIVOT_BACK
        // Then center at world z = -CAROUSEL_PIVOT_BACK + CAROUSEL_RADIUS
        // For center at z = 0: CAROUSEL_RADIUS = CAROUSEL_PIVOT_BACK
        // But we use CAROUSEL_RADIUS for spacing, so ensure they match for proper centering
        carouselGroups[type].position.z = -CAROUSEL_PIVOT_BACK;
      });
    
    // Legacy groups for backward compatibility with welcome animation
    const groups = { 
      shirts: carouselGroups.shirts, 
      pants: carouselGroups.pants,
      shoes: carouselGroups.shoes,
      dresses: carouselGroups.dresses
    };
    
    // Master group to hold all clothing for easy translation and rotation
    const clothingGroup = new THREE.Group();
    clothingGroup.add(groups.shirts, groups.pants, groups.shoes, groups.dresses);
    scene.add(clothingGroup);
    
    // Initial position: right-center (translated to the right and lower)
    clothingGroup.position.x = initialX;
    clothingGroup.position.y = initialY;
    
    // Rotation state - start from 0, continuously rotating at the right position
    let rotationSpeed = 0.005; // radians per frame
    let currentRotation = 0;
    let isRotating = true;
    clothingGroup.rotation.y = 0; // Start at rotation 0 (starting position)
    
    // Normalize rotation to prevent accumulation beyond one rotation
    const MAX_ROTATION = Math.PI * 2; // one full rotation

    // Toast notifications removed - no longer showing
    function showToast(message) {
      // Toast functionality disabled
      console.log(message); // Log to console instead
    }

    function separateShoes(object) {
      // Collect all mesh objects that could be shoes
      const meshes = [];
      object.traverse((child) => {
        if (child.isMesh) {
          meshes.push(child);
        }
      });

      // If we have 2 or more meshes, try to separate them
      if (meshes.length >= 2) {
        // Calculate bounding boxes for each mesh
        const boxes = meshes.map((mesh) => {
          const box = new THREE.Box3().setFromObject(mesh);
          return { mesh, box, center: box.getCenter(new THREE.Vector3()) };
        });

        // Sort by x position (left to right)
        boxes.sort((a, b) => a.center.x - b.center.x);

        // Calculate the overall width
        const overallBox = new THREE.Box3().setFromObject(object);
        const overallWidth = overallBox.max.x - overallBox.min.x;

        // Separate the shoes horizontally
        const separation = Math.max(0.8, overallWidth * 0.4); // at least 0.8 units apart
        const leftShoe = boxes[0];
        const rightShoe = boxes[boxes.length - 1];

        // Move left shoe left, right shoe right
        if (leftShoe.mesh.parent) {
          leftShoe.mesh.position.x -= separation / 2;
        }
        if (rightShoe.mesh.parent && rightShoe.mesh !== leftShoe.mesh) {
          rightShoe.mesh.position.x += separation / 2;
        }
      }
    }

    function centerAndPlace(object, type, slot = 'current', url = '', index = -1) {
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      object.position.sub(center); // center model at origin

      // Shoes no longer need separation - keep as single model

      // For dresses, adjust vertical offset based on index
      let yOffset;
      if (type === "dresses") {
        if (index === 0) {
          // First dress - keep at current lower position
          yOffset = verticalOffsets[type] - box.min.y + 0.25;
        } else {
          // Second and third dresses - position higher up
          const higherOffset = verticalOffsets[type] + 0.4; // Add extra height
          yOffset = higherOffset - box.min.y + 0.25;
        }
      } else {
        yOffset = verticalOffsets[type] - box.min.y + 0.25; // keep a small gap from the "ground"
      }
      
      object.position.y += yOffset;

      // scale overall, but make shoes significantly smaller
      // Check if pants item is actually a short and scale it down
      let scaleTarget = 1.0;
      let zAdjustment = zOffsets[type]; // Start with base z offset
      
      if (type === "shoes") {
        scaleTarget = 0.5;
      } else if (type === "pants") {
        // Check if this is a short based on file path
        const isAShort = isShort(url);
        scaleTarget = isAShort ? 0.6 : 1.2; // Shorts scaled down, pants normal
        object.position.y += isAShort ? 0.7:0;
      } else if (type === "dresses") {
        // First dress (index 0) is larger, others are normal size
        scaleTarget = (index === 0) ? 1.6 : 1.0; // Increased first dress size
      }
      
      // Apply z offset after all adjustments
      object.position.z += zAdjustment;
      
      const maxDimension = Math.max(size.x, size.y, size.z);
      if (maxDimension > 0) {
        const s = (scaleTarget * 2.0) / maxDimension;
        object.scale.setScalar(s);
      }
      
      // Apply carousel slot positioning
      // Items are positioned on a circle around a pivot point
      // Their rotation naturally follows their position on the circle
      // When the carousel rotates, items smoothly move around the circle
      if (slot === 'prev') {
        // Left-back position on the carousel circle
        const angle = -CAROUSEL_ANGLE;
        // Position on circle relative to pivot point (carousel group origin)
        object.position.x = CAROUSEL_RADIUS * Math.sin(angle);
        object.position.z = CAROUSEL_RADIUS * Math.cos(angle);
        // Rotation matches the angle on the circle - naturally oriented based on position
        object.rotation.y = angle;
        object.scale.multiplyScalar(CAROUSEL_SCALE_SIDE);
      } else if (slot === 'next') {
        // Right-back position on the carousel circle
        const angle = CAROUSEL_ANGLE;
        object.position.x = CAROUSEL_RADIUS * Math.sin(angle);
        object.position.z = CAROUSEL_RADIUS * Math.cos(angle);
        // Rotation matches the angle on the circle - naturally oriented based on position
        object.rotation.y = angle;
        object.scale.multiplyScalar(CAROUSEL_SCALE_SIDE);
      } else if (slot === 'current') {
        // Current item is at the center of the carousel (angle 0)
        object.position.x = 0;
        // Preserve any z adjustments that were made (e.g., for shoes)
        // Add CAROUSEL_RADIUS to the current z position instead of overwriting it
        const currentZ = object.position.z;
        object.position.z = CAROUSEL_RADIUS + currentZ;
        // At center, facing forward
        object.rotation.y = 0;
      }
    }

    function loadModelToSlot(type, index, slot) {
      const total = assets[type].length;
      const normalizedIndex = (index + total) % total;
      const url = assets[type][normalizedIndex];
      
      return new Promise((resolve, reject) => {
      loader.load(
        url,
        (gltf) => {
            carouselSlots[type][slot].clear();
          gltf.scene.traverse((child) => { child.castShadow = true; });
            centerAndPlace(gltf.scene, type, slot, url, normalizedIndex);
            carouselSlots[type][slot].add(gltf.scene);
            resolve(gltf.scene);
        },
        undefined,
        (err) => {
          console.error(`Failed to load ${url}`, err);
            reject(err);
          }
        );
      });
    }
    
    function loadAllCarouselItems(type, showAll = false) {
      const total = assets[type].length;
      const currentIndex = current[type];
      
      // Only load current item - no prev/next
      const promises = [loadModelToSlot(type, currentIndex, 'current')];
      
      return Promise.all(promises).then(() => {
        // Always hide prev/next items - only show current
        carouselSlots[type].prev.visible = false;
        carouselSlots[type].next.visible = false;
        // Update rotations after loading
        updateItemRotations(type, carouselRotationState[type] || 0);
        // Toast removed
      }).catch((err) => {
          console.error("Failed to load asset. Check console.");
        return Promise.reject(err);
      });
    }
    
    // Legacy function for initial load (only show current during welcome)
    function loadModel(type, index) {
      current[type] = index;
      loadAllCarouselItems(type, false);
    }

    // Carousel rotation state
    const carouselRotationState = { shirts: 0, pants: 0, shoes: 0, dresses: 0 };
    const carouselAnimationState = { shirts: false, pants: false, shoes: false, dresses: false };
    const CAROUSEL_ROTATION_DURATION = 600; // milliseconds
    
    // Function to update item rotations as they move around the carousel
    // Simple approach: rotation directly matches the angle position on the circle
    // This creates a natural carousel effect where items rotate smoothly as they move
    function updateItemRotations(carouselType, carouselRotation) {
        // Calculate current angle positions of each slot as carousel rotates
        // As the carousel group rotates, items' positions on the circle change
        const prevAngle = -CAROUSEL_ANGLE + carouselRotation;
        const currentAngle = 0 + carouselRotation;
        const nextAngle = CAROUSEL_ANGLE + carouselRotation;
        
        // Rotation simply matches the angle position on the circle
        // This creates natural orientation as items move around the carousel
        function getRotationForAngle(angle) {
          // Normalize angle to [-π, π]
          let normalizedAngle = ((angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
          if (normalizedAngle > Math.PI) normalizedAngle -= Math.PI * 2;
          return normalizedAngle;
        }
        
        // Update each slot's rotation to match its current position on the circle
        const prevSlot = carouselSlots[carouselType].prev;
        const currentSlot = carouselSlots[carouselType].current;
        const nextSlot = carouselSlots[carouselType].next;
        
        if (prevSlot.children.length > 0) {
          const scene = prevSlot.children[0];
          if (scene && scene.isObject3D) {
            scene.rotation.y = getRotationForAngle(prevAngle);
          }
        }
        
        if (currentSlot.children.length > 0) {
          const scene = currentSlot.children[0];
          if (scene && scene.isObject3D) {
            scene.rotation.y = getRotationForAngle(currentAngle);
          }
        }
        
        if (nextSlot.children.length > 0) {
          const scene = nextSlot.children[0];
          if (scene && scene.isObject3D) {
            scene.rotation.y = getRotationForAngle(nextAngle);
          }
        }
      }
    
    // Update arrow controls and mode button visibility based on current mode
    function updateModeUI() {
      const shirtsControls = document.querySelector('.arrow-controls.shirts');
      const pantsControls = document.querySelector('.arrow-controls.pants');
      const dressesControls = document.querySelector('.arrow-controls.dresses');
      const modeButton = document.getElementById('mode-button');
      
      if (!shirtsControls || !pantsControls || !dressesControls || !modeButton) return;
      
      if (currentMode === 'casual') {
        // Show shirts and pants controls, hide dresses
        shirtsControls.style.display = 'flex';
        shirtsControls.classList.add('visible');
        pantsControls.style.display = 'flex';
        pantsControls.classList.add('visible');
        dressesControls.style.display = 'none';
        dressesControls.classList.remove('visible');
        modeButton.textContent = 'Dresses';
      } else if (currentMode === 'dresses') {
        // Hide shirts and pants controls, show dresses with single arrow pair
        shirtsControls.style.display = 'none';
        shirtsControls.classList.remove('visible');
        pantsControls.style.display = 'none';
        pantsControls.classList.remove('visible');
        dressesControls.style.display = 'flex';
        dressesControls.classList.add('visible');
        
        // Show both arrows for dresses (prev/next)
        const leftBtn = dressesControls.querySelector('.arrow-btn.left');
        const rightBtn = dressesControls.querySelector('.arrow-btn.right');
        if (leftBtn && rightBtn) {
          leftBtn.style.display = 'flex';
          rightBtn.style.display = 'flex';
        }
        
        modeButton.textContent = 'Casual';
      }
    }

    function switchItem(type, dir) {
      if (carouselAnimationState[type]) return; // Don't allow switching during loading
      
      const total = assets[type].length;
      const newIndex = (current[type] + dir + total) % total;
      current[type] = newIndex;
      
      // Simply load the new item directly - no animation
      carouselAnimationState[type] = true;
      loadAllCarouselItems(type).then(() => {
        // Reset rotation state
        carouselRotationState[type] = 0;
        carouselGroups[type].rotation.y = 0;
        updateItemRotations(type, 0);
        carouselAnimationState[type] = false;
      });
    }
    
    // Mode switching function
    function switchMode() {
      if (currentMode === 'casual') {
        // Switch to dresses mode
        currentMode = 'dresses';
        
        // Hide shirts and pants
        if (groups.shirts) groups.shirts.visible = false;
        if (groups.pants) groups.pants.visible = false;
        if (groups.shoes) groups.shoes.visible = true; // Keep shoes visible
        
        // Show and load dresses
        if (groups.dresses) groups.dresses.visible = true;
        
        // Load first dress
        if (assets.dresses && assets.dresses.length > 0) {
          current.dresses = 0;
          carouselAnimationState['dresses'] = true;
          loadAllCarouselItems('dresses').then(() => {
            carouselRotationState['dresses'] = 0;
            carouselGroups['dresses'].rotation.y = 0;
            updateItemRotations('dresses', 0);
            carouselAnimationState['dresses'] = false;
          }).catch(err => {
            console.error('Error loading dresses:', err);
            carouselAnimationState['dresses'] = false;
          });
        }
      } else {
        // Switch to casual mode
        currentMode = 'casual';
        
        // Hide dresses
        if (groups.dresses) groups.dresses.visible = false;
        
        // Show shirts and pants
        if (groups.shirts) groups.shirts.visible = true;
        if (groups.pants) groups.pants.visible = true;
        if (groups.shoes) groups.shoes.visible = true;
        
        // Reload shirts and pants
        if (assets.shirts && assets.shirts.length > 0) {
          carouselAnimationState['shirts'] = true;
          loadAllCarouselItems('shirts').then(() => {
            carouselRotationState['shirts'] = 0;
            carouselGroups['shirts'].rotation.y = 0;
            updateItemRotations('shirts', 0);
            carouselAnimationState['shirts'] = false;
          }).catch(err => {
            console.error('Error loading shirts:', err);
            carouselAnimationState['shirts'] = false;
          });
        }
        if (assets.pants && assets.pants.length > 0) {
          carouselAnimationState['pants'] = true;
          loadAllCarouselItems('pants').then(() => {
            carouselRotationState['pants'] = 0;
            carouselGroups['pants'].rotation.y = 0;
            updateItemRotations('pants', 0);
            carouselAnimationState['pants'] = false;
          }).catch(err => {
            console.error('Error loading pants:', err);
            carouselAnimationState['pants'] = false;
          });
        }
      }
      
      // Update UI after a brief delay to ensure visibility changes
      setTimeout(() => {
        updateModeUI();
      }, 10);
    }

    // Event listeners for arrow buttons
    document.querySelectorAll(".arrow-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        const type = btn.dataset.type;
        const dir = Number(btn.dataset.dir);
        switchItem(type, dir);
      });
    });
    
    // Mode button event listener
    const modeButton = document.getElementById('mode-button');
    if (modeButton) {
      modeButton.addEventListener('click', () => {
        switchMode();
      });
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener("resize", onResize);

    // Welcome overlay setup
    const welcomeOverlay = document.getElementById("welcome-overlay");
    const goButton = document.getElementById("go-button");
    
    let isAnimating = false;
    const animationDuration = 1200; // milliseconds
    let animationStartTime = null;
    let initialRotationValue = 0; // will be set when button is clicked
    
    function startAnimation() {
      if (isAnimating) return;
      
      isAnimating = true;
      isRotating = false; // Stop the rotation
      welcomeOverlay.classList.add("slide-out");
      
      // Capture the current rotation as the initial value (normalized to 0-2π)
      initialRotationValue = currentRotation % MAX_ROTATION;
      if (initialRotationValue < 0) initialRotationValue += MAX_ROTATION;
      
      // Start the clothing animation
      animationStartTime = performance.now();
      
      function animateClothing() {
        if (!isAnimating) return;
        
        const elapsed = performance.now() - animationStartTime;
        const progress = Math.min(elapsed / animationDuration, 1);
        
        // Easing function (ease-out-cubic)
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        
        // Smoothly rotate back to 0 (initial position) while translating to center
        const targetRotation = 0;
        currentRotation = initialRotationValue + (targetRotation - initialRotationValue) * easeProgress;
        clothingGroup.rotation.y = currentRotation;
        
        // Smoothly translate from initial position to center (horizontally and vertically)
        const startX = isMobile ? leftCenterX : rightCenterX;
        const startY = isMobile ? leftCenterY : rightCenterY;
        const targetX = targetCenterX;
        clothingGroup.position.x = startX + (targetX - startX) * easeProgress;
        
        // Smoothly translate from lower position to target height
        const targetY = targetCenterY;
        clothingGroup.position.y = startY + (targetY - startY) * easeProgress;
        
        // Camera target stays at center (already at 0), no need to animate it
        
        if (progress < 1) {
          requestAnimationFrame(animateClothing);
        } else {
          // Animation complete
          clothingGroup.position.x = targetCenterX;
          clothingGroup.position.y = targetCenterY;
          clothingGroup.rotation.y = 0;
          currentRotation = 0;
          isAnimating = false;
          // Show arrow controls and mode button when items reach center
          document.querySelectorAll(".arrow-controls.visible").forEach(ctrl => {
            ctrl.classList.add("visible", "show-after-click");
          });
          const modeButton = document.getElementById('mode-button');
          if (modeButton) modeButton.classList.add('visible');
          
          // Reload all items (only current, no prev/next)
          ["shirts", "pants", "shoes"].forEach((type) => {
            if (assets[type] && assets[type].length > 0) {
              loadAllCarouselItems(type, false);
            }
          });
          // Initialize mode UI
          updateModeUI();
        }
      }
      
      requestAnimationFrame(animateClothing);
    }
    
    goButton.addEventListener("click", startAnimation);

    // Initialize: load initial models
    // Verify we have assets before loading
    const hasAssets = Object.values(assets).some(arr => arr.length > 0);
    if (hasAssets) {
      // Both mobile and desktop: show welcome screen, load initial models
      // On mobile, welcome screen is full screen
      // On desktop, it's half screen
      ["shirts", "pants", "shoes"].forEach((type) => {
        if (assets[type] && assets[type].length > 0) {
          loadModel(type, 0);
        }
      });
      // Initialize mode UI
      updateModeUI();
    } else {
      console.error("No assets found in manifest.");
    }

    function animate() {
      requestAnimationFrame(animate);
      
      // Rotate clothing in place at the start (continuous rotation around initial offset)
      if (isRotating) {
        currentRotation += rotationSpeed;
        clothingGroup.rotation.y = currentRotation;
      }
      
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>

